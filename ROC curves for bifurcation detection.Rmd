---
title: "R Notebook"
output: html_notebook
---
```{r}
library(BSDA)
```


#ROC-curves for bifurcation detection
The purpose of this notebook is to
1) Develop a scheme for simulating the dynamics of a double-well potential with additive(for now) noise.
2) Compute hypothesis tests only using data from a restricted time interval.
3) Compute (and plot) ROC curves for different significance threshholds, control parameter speed, observation frequency and variance.

## Simulation of paths
```{r}
make_path <- function(x0, beta4 = 1, beta2 = 1, sigma = 1, tmax = 2, deltat = 0.01, lambda0 = 0.5, lambda_end){
  t <- seq(from = 0, to = tmax, by = deltat)
  x <- numeric(length = length(t))
  x[1] <- x0
  dW <- rnorm(n = length(t) - 1)
  lambda <- seq(from = lambda0, to = lambda_end, along.with = t)
  drift <- function(x, lambda){
    -beta4*x^3 + beta2*x + lambda
  }
  for (i in (2:length(t))){
    x[i] <- x[i-1] + drift(x = x[i-1], lambda = lambda[i-1])*deltat + dW[i]*sqrt(deltat)*sigma
  }
  data.frame(t,x)
}
```
We test that the function works:
```{r}
test_path <- make_path(x0 = 1, sigma = 0.05, tmax = 10, deltat = 0.01, lambda0 = 0, lambda_end = -1)
plot(test_path$x)
```
It is worth noting that even with relatively strong parameter movement over the time period, we are not guaranteed to cross the 0 point.
This also depends on the noise.
It is also worth noting that the equilibrium value of x at the time of bifurcation is 0.6, so we would not necessarily expect to have crossed 0 by the end of the simulation.
Increasing the time of running also gives the process time to "settle in" to its new equilibrium.
It might be interesting to make a plot of a number of simulated paths over different parameters.
We desire a controlled experiment where we know the exact time of bifurcation.
Thus, we need to do some setup computation to establish the critical value of the control parameter.
By considering the derivative of the drift we find that it has two roots.
Superimposing the drift with the derivative of the drift shows that the larger root of the derivative is the value of x where the saddle-node bifurcation occurs. We can evaluate $F(x,\lambda)$ in $x = \frac{1}{sqrt{3}}$ and solve the resulting equation for lambda.
In the case where $\beta_4 = \beta_2 = 1$, we get $\lambda_c = \frac{2}{3 sqrt{3}}$.
Since we now have a procedure for finding the bifurcation points, we can in principle automate the scaling of dlambda such that bifurcation always occurs at the end of the simulation. In that case we need to make sure that the initial value of lambda is a pre-bifurcation state.
I suppose the easiest way to implement linear movement of the control parameter towards the critical value is through the seq function.
This also easily lets us introduce an equilibrium period at the start if we so desire.

##Estimation and hypothesis testing
```{r}
hypothesis_tester <- function(data, beta4 = 1, beta2 = 1, classifier = z_test){
  x <- data$x
  t <- data$t
  deltat <- t[2] - t[1]
  drift <- function(x){
    -beta4*x^3 + beta2*x
  }
  x_predicted <- numeric(length = length(x))
  x_predicted[1] <- x[1]
  for (i in (2:length(x_predicted))){
    x_predicted[i] <- x[i-1] + drift(x[i-1])*deltat
  }
  residuals <- (x-x_predicted)[2:length(x)]
  out <- z_test(residuals)
  out
}
```

```{r}
z_test <- function(x, alpha = 0.6){
  rejected <- 0
  Z <- mean(x, na.rm = TRUE)/sd(x, na.rm = TRUE)
  if (pnorm(abs(Z)) > 1-(1-alpha)/2){
    rejected <- 1 #Reject = true => bifurcation detected
  }
  out <- c(rejected, Z)
}
```

We test that the function works:
```{r}
test_path <- make_path(x0 = 1, sigma = 0.05, tmax = 10, deltat = 0.01, lambda0 = 0, lambda_end = -1)
hypothesis_tester(data = test_path)

```
## Computing ROC curves
To compute and plot ROC curves we need a vector of parameters along with their associated false positive rates and true positive rates.
The plan is as follows:
1) Provide vector of thresholds
2) Compute false positive rates
3) Compute true positive rates
4) Make graph
5) Compute AOC

### Computing positive rates, true and false
We should probably start with points 2 and 3.
A single MC function should do both, given different inputs: true and false inputs.
```{r}
positive_rate_computer <- function(model, method, n = 100){
  #browser()
  positives <- 0
  for (i in (1:n)){
    test_path <- model()
    positive <- method(test_path)[1]
    positives <- positives + positive
  }
  rate <- positives/n
  rate
}
```
Let's test the above function
```{r}
#Defining the parameters for the rate computation
model_H1 <- function(){
  make_path(x0 = 1, sigma = 0.05, tmax = 10, deltat = 0.01, lambda0 = 0, lambda_end = -1)
}
method <- hypothesis_tester
```
```{r}
true_positive_rate <- positive_rate_computer(model = model_H1, method = method, n = 100)
```

### Computing positive rates for a vector of thresholds
We propose the following procedure:
Create a list of thresholds (This probably has to be hand-made for each method)
Create a list of "methods" that is a given method for the different thresholds
Apply the positive rate function to the list of methods. This probably requires making a function that takes only a method as argument.
Do the above again for true/false.
Combine vectors and plot/compute AOC.

We start by making a vector of thresholds:
```{r}
u <- seq(from = 0, to = 1, by = 0.1)
thresh <- qnorm(u)[2:(length(u)-1)]
```
Now me make a function creating a list of methods - one for each threshold.
```{r}
z_tester_maker <- function(thresh){
  z_test <- function(x, alpha = thresh){
    rejected <- 0
    Z <- mean(x, na.rm = TRUE)/sd(x, na.rm = TRUE)
    if (pnorm(abs(Z)) > 1-(1-alpha)/2){
      rejected <- 1 #Reject = true => bifurcation detected
    }
    out <- c(rejected, Z)
  }
  hypothesis_tester <- function(data, beta4 = 1, beta2 = 1, classifier = z_test){
    x <- data$x
    t <- data$t
    deltat <- t[2] - t[1]
    drift <- function(x){
      -beta4*x^3 + beta2*x
    }
    x_predicted <- numeric(length = length(x))
    x_predicted[1] <- x[1]
    for (i in (2:length(x_predicted))){
      x_predicted[i] <- x[i-1] + drift(x[i-1])*deltat
    }
    residuals <- (x-x_predicted)[2:length(x)]
    out <- z_test(residuals)
    out
  }
  hypothesis_tester
}
```

```{r}
z_testers <- lapply(X = thresh, FUN = z_tester_maker)
```
In order to compute rates for each threshold on the same set of paths we need to restructure slightly.
In the example computed, the rate computer generates the paths that it classifies.
We need the rate computer to take the set of paths as input.



