---
title: "Misspecification of drift"
author: "Axel Szetu"
date: "2024-06-06"
output: html_document
---

The following notebook is written as an extension to the notebook AMOCestimation released as supplementary material to Ditlevsen et Al 2023.
THe purpose is to test the performance of the likelihood-based estimator of tipping time in a scenario where the drift is misspecified.
To this end, we will simulate realizations from a model with double-well potential and use the likelihood of 3'rd degree polynomial model to estimate the tipping time and simulate the distribution of the estimator.

We define the parameters of the simulation
```{r}
beta_4 <- 1
beta_2 <- 1
lambda_0 <- 1
lambda_c <- -0.4
t <- seq(0, 300, by = 1/12)
t_0 <- 100
tau <- 200
t_end <- t_0 + tau
h <- c(rep(0, 1200), seq(from = 0, to = 1, length.out = 2401))
lambda_t <- (1-h)*lambda_0 + h*lambda_c
x_0 <- 1.3
dt <- 1/12
nloop <- 20
sigma <- 0.5
```

We define a function to simulate a path given a list of parameters
```{r}
make_path <- function(x_0 = 1.3, betas = c(1,1), t_0 = 100, t_end = 300, lambda_0 = 1, lambda_c = -0.4, dt = 1/12, nloop = 2, sigma = 0.1){
  #browser()
  delta_t <- dt/nloop
  n_0 <- t_0/dt*nloop
  n_r <- (t_end-t_0)/dt*nloop
  n_total <- n_0 + n_r + 1
  t <- seq(from = 0, to = t_end, length.out = n_total)
  h <- c(rep(0, n_0), seq(from = 0, to = 1, length.out = n_r))
  lambda_t <- (1-h)*lambda_0 + h*lambda_c
  beta_4 <- betas[1]
  beta_2 <- betas[2]
  drift <- function(x, lambda){
    out <- -(beta_4*x^3) + beta_2*x + lambda
    out
  }
  X <- numeric(length = n_total)
  X[1] <- x_0
  dW <- rnorm(n = n_total, mean = 0, sd = 1)
  for (i in (2:n_total)){
    X[i] <- X[i-1] + drift(X[i-1],lambda_t[i-1])*delta_t + dW[i-1]*sigma*sqrt(delta_t)
  }
  out <- data.frame(t, X)
  out <- out[1 + nloop*(0:floor(n_total/nloop)),]
  out
}
test_path <- make_path()
plot(y = test_path$X, x = test_path$t)
```

We estimate parameters of OU
```{r, eval = FALSE}
data_OU <- test_path[test_path$t <= t_0, "X"]
temp   = estimate.OU(data = data_OU, delta = 1/12)
alpha0 = unname(coef(temp)["alpha"])
mu0    = unname(coef(temp)["mu"])
sigma2 = unname(coef(temp)["sigma2"])
```

We estimate tipping time
```{r, eval = FALSE}
#We had to edit the estimate.tipping function to take absolute value before applying square root
data_ramp <- test_path[(test_path$t > t_0) & (test_path$t <= 200), "X"]
temp = estimate.tipping(data = data_ramp, delta = 1/12, initial.values = c(200,2),
                        alpha0 = alpha0, mu0 = mu0, sigma20 = sigma2, 
                        pen = 0.004)
tau     = unname(temp$par[1])
a       = unname(temp$par[2])
m       = mu0 - alpha0/(2 * a)
lambda0 = -alpha0^2/(4 * a)
tc      = tau + t0
```
Collecting estimates
```{r, eval = FALSE}
## Collect estimates (not that they can all be meaningfully interpreted in this scenario)
round(c(t0 = t0, alpha0 = alpha0, mu0 = mu0, sigma2 = sigma2, tau = tau, 
        a = a, m = m, lambda0 = lambda0, tc = tc),2)
```

We benchmark make_path, estimate.OU and estimate.tipping to know approximately how long a simulation with n=1000 will take.
```{r}
library(microbenchmark)
microbenchmark(make_path(nloop = 20), times = 10)
microbenchmark(estimate.OU(data = data_OU, delta = 1/12), times = 10)
microbenchmark(estimate.tipping(data = test_path$X[1201:2401], alpha0 = alpha0, mu0 = mu0, sigma2 = sigma2, delta = 1/12, pen = 0.004, initial.values = c(100, 1)), times = 10)
```

We simulate data and gather it into a matrix
```{r}
#Define parameters below
#
#
#
t_obs <- 200
nsim <- 1000
sim_length <- t_end/dt + 1
sim_data <- matrix(nrow = sim_length, ncol = nsim)
for (i in (1:nsim)){
  path <- make_path(nloop = 20)
  sim_data[,i] <- path$X
}
sim_data <- as.data.frame(sim_data)
sim_data$t <- seq(from = 0, to = t_end, by = dt)
```


We estimate on each path and gather estimates into a matrix.
The relevant quantities are alpha0, mu0, sigma2, tau.
The first three come from OU, the last comes from tipping.
```{r}
estimates_matrix <- matrix(nrow = nsim, ncol = 4)
colnames(estimates_matrix) <- c("alpha0", "mu0", "sigma2", "tau")
n_0 <- t_0/dt
n_ramp <- (t_obs-t_0)/dt
for (i in (1:nsim)){
  data_tmp <- sim_data[,i]
  data_OU <- data_tmp[1:n_0]
  estimates_OU <- estimate.OU(data = data_OU, delta = dt)
  alpha0_tmp <- unname(coef(estimates_OU)["alpha"])
  mu0_tmp <- unname(coef(estimates_OU)["mu"])
  sigma2_tmp <- unname(coef(estimates_OU)["sigma2"])
  data_ramp <- data_tmp[(n_0 + 1):(n_0 + n_ramp)]
  estimates_ramp <- estimate.tipping(data = data_ramp, delta = dt, initial.values = c(100, 1), alpha0 = alpha0_tmp, mu0 = mu0_tmp, sigma20 = sigma2_tmp, pen = 0.004)
  tau_tmp <- estimates_ramp$par[1]
  estimates_matrix[i,] <- c(alpha0_tmp, mu0_tmp, sigma2_tmp, tau_tmp)
}
estimates_matrix
```
We get some estimates that are completely off the mark.

```{r}
for (i in (1:5)){
  plot(sim_data[,i])
}
```


